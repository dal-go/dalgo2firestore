package dalgo2firestore

import (
	"context"
	"errors"
	"fmt"
	"time"

	"cloud.google.com/go/firestore"
	"github.com/dal-go/dalgo/dal"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func (db database) RunReadonlyTransaction(ctx context.Context, f dal.ROTxWorker, options ...dal.TransactionOption) (err error) {
	var started time.Time
	if Debugf != nil {
		started = time.Now()
	}
	options = append(options, dal.TxWithReadonly())
	firestoreTxOptions := createFirestoreTransactionOptions(options)
	err = db.client.RunTransaction(ctx, func(ctx context.Context, tx *firestore.Transaction) error {
		return f(ctx, transaction{db: db, tx: tx, QueryExecutor: db.QueryExecutor})
	}, firestoreTxOptions...)
	if Debugf != nil {
		Debugf(ctx, "RunReadonlyTransaction() completed in %v, err: %v", time.Since(started), err)
	}
	return
}

func (db database) RunReadwriteTransaction(ctx context.Context, f dal.RWTxWorker, options ...dal.TransactionOption) (err error) {
	var started time.Time
	if Debugf != nil {
		started = time.Now()
	}
	firestoreTxOptions := createFirestoreTransactionOptions(options)
	err = db.client.RunTransaction(ctx, func(ctx context.Context, tx *firestore.Transaction) error {
		return f(ctx, transaction{db: db, tx: tx, QueryExecutor: db.QueryExecutor})
	}, firestoreTxOptions...)
	if Debugf != nil {
		Debugf(ctx, "RunReadwriteTransaction() completed in %v, err: %v", time.Since(started), err)
	}
	return err
}

func createFirestoreTransactionOptions(opts []dal.TransactionOption) (options []firestore.TransactionOption) {
	to := dal.NewTransactionOptions(opts...)
	if to.IsReadonly() {
		options = append(options, firestore.ReadOnly)
	}
	return
}

var _ dal.Transaction = (*transaction)(nil)
var _ dal.ReadwriteTransaction = (*transaction)(nil)

type transaction struct {
	db      database
	tx      *firestore.Transaction
	options dal.TransactionOptions
	dal.QueryExecutor
}

func (tx transaction) Close(_ context.Context) error {
	panic("TODO: implement or remove me")
}

func (tx transaction) ID() string {
	return ""
}

func (tx transaction) Options() dal.TransactionOptions {
	return tx.options
}

func (tx transaction) Insert(ctx context.Context, record dal.Record, opts ...dal.InsertOption) (err error) {
	record.SetError(nil) // !Important - we need to set the error to nil before accessing record.Data()

	// This data validation has to be executed by dalgo dal package.
	if validatable, ok := record.Data().(interface{ Validate() error }); ok {
		if err = validatable.Validate(); err != nil {
			return fmt.Errorf("record data is invalid: %w", err)
		}
	}

	var started time.Time
	if Debugf != nil {
		started = time.Now()
	}
	options := dal.NewInsertOptions(opts...)
	idGenerator := options.IDGenerator()
	record.SetError(nil) // Mark the record as not having an error
	if idGenerator != nil {
		existsFunc := func(key *dal.Key) (err error) {
			docRef := keyToDocRef(key, tx.db.client)
			_, err = docRef.Get(ctx)
			if status.Code(err) == codes.NotFound {
				err = dal.NewErrNotFoundByKey(key, err)
			}
			return err
		}
		insertFunc := func(record dal.Record) error {
			key := record.Key()
			docRef := keyToDocRef(key, tx.db.client)
			data := record.Data()
			if err = tx.tx.Create(docRef, data); err != nil {
				return err
			}
			return nil
		}
		return dal.InsertWithIdGenerator(ctx, record, idGenerator, 10,
			existsFunc,
			insertFunc,
		)
	}
	key := record.Key()

	data := record.Data()

	if key.ID == nil {
		collectionRef := keyToCollectionRef(key, tx.db.client)
		var docRef *firestore.DocumentRef
		docRef, _, err = collectionRef.Add(ctx, data)
		if err != nil {
			record.SetError(fmt.Errorf("failed to add record with autogenerated ID: %w", err))
			return
		}
		key.ID = docRef.ID
	} else {
		docRef := keyToDocRef(key, tx.db.client)
		if err = tx.tx.Create(docRef, data); err != nil {
			record.SetError(fmt.Errorf("failed to create record with manually generated ID: %w", err))
			return
		}
	}

	if Debugf != nil {
		Debugf(ctx, "tx.Insert(%v) completed in %v, err: %v", key, time.Since(started), err)
	}
	return
}

func (tx transaction) Upsert(ctx context.Context, record dal.Record) error {
	return tx.Set(ctx, record)
}

func (tx transaction) getByDocRef(_ context.Context, dr *firestore.DocumentRef) (*firestore.DocumentSnapshot, error) {
	return tx.tx.Get(dr)
}

func (tx transaction) Get(ctx context.Context, record dal.Record) error {
	return getAndUnmarshal(ctx, record, tx.db.client, tx.getByDocRef)
}

func (tx transaction) Exists(ctx context.Context, key *dal.Key) (exists bool, err error) {
	return existsByKey(ctx, key, tx.db.client, tx.getByDocRef)
}

func (tx transaction) Set(ctx context.Context, record dal.Record) (err error) {
	var started time.Time
	if Debugf != nil {
		started = time.Now()
	}
	key := record.Key()
	dr := keyToDocRef(key, tx.db.client)
	err = tx.tx.Set(dr, record.Data())
	if Debugf != nil {
		Debugf(ctx, "tx.Set(%v) completed in %v, err: %v", key, time.Since(started), err)
	}
	return err
}

func (tx transaction) Delete(ctx context.Context, key *dal.Key) (err error) {
	var started time.Time
	if Debugf != nil {
		started = time.Now()
	}
	dr := keyToDocRef(key, tx.db.client)
	err = tx.tx.Delete(dr)
	if Debugf != nil {
		Debugf(ctx, "tx.Delete(%v) completed in %v, err: %v", key, time.Since(started), err)
	}
	return
}

func (tx transaction) GetMulti(ctx context.Context, records []dal.Record) error {
	return getMulti(ctx, records, "tx", tx.db.client,
		func(_ context.Context, drs []*firestore.DocumentRef) ([]*firestore.DocumentSnapshot, error) {
			return tx.tx.GetAll(drs)
		},
	)
}

func getMulti(
	ctx context.Context,
	records []dal.Record,
	caller string,
	client *firestore.Client,
	getAll func(ctx context.Context, drs []*firestore.DocumentRef) ([]*firestore.DocumentSnapshot, error),
) (err error) {
	var started time.Time
	if Debugf != nil {
		started = time.Now()
	}
	dr := make([]*firestore.DocumentRef, len(records))
	for i, r := range records {
		dr[i] = keyToDocRef(r.Key(), client)
	}

	var ds []*firestore.DocumentSnapshot
	if ds, err = getAll(ctx, dr); err != nil {
		return fmt.Errorf("failed to getFirestore %d records by keys: %w", len(records), err)
	}

	var errs []error
	for i, d := range ds {
		if err = docSnapshotToRecord(d, records[i], dataTo); err != nil {
			errs = append(errs, err)
		}
	}

	if len(errs) > 0 {
		err = fmt.Errorf(caller+".getMulti() failed to getFirestore %d out of %d records requested by keys: %w", len(errs), len(records), errors.Join(errs...))
	}

	logMultiRecords(ctx, caller+".GetMulti", records, started, err)

	return nil

}

func (tx transaction) SetMulti(ctx context.Context, records []dal.Record) (err error) {
	var started time.Time
	if Debugf != nil {
		started = time.Now()
	}
	for _, record := range records { // TODO: can we do this in parallel?
		doc := keyToDocRef(record.Key(), tx.db.client)
		record.SetError(nil) // Mark record as not having an error
		_, err = doc.Set(ctx, record.Data())
		if err != nil {
			record.SetError(err)
			break
		}
	}
	logMultiRecords(ctx, "tx.SetMulti", records, started, err)
	return nil
}

func (tx transaction) DeleteMulti(ctx context.Context, keys []*dal.Key) (err error) {
	var started time.Time
	if Debugf != nil {
		started = time.Now()
	}
	for _, k := range keys {
		dr := keyToDocRef(k, tx.db.client)
		if err = tx.tx.Delete(dr); err != nil {
			err = fmt.Errorf("failed to deleteByDocRef record: %w", err)
			break
		}
	}
	logMultiKeys(ctx, "tx.DeleteMulti", keys, started, err)
	return nil
}

func (tx transaction) InsertMulti(ctx context.Context, records []dal.Record, opts ...dal.InsertOption) (err error) {
	var started time.Time
	if Debugf != nil {
		started = time.Now()
	}
	_, err = insertMulti(ctx, tx.db, records, func(ctx context.Context, docRef *firestore.DocumentRef, data any) (result *firestore.WriteResult, err error) {
		return nil, tx.tx.Create(docRef, data)
	}, opts...)
	logMultiRecords(ctx, "tx.InsertMulti", records, started, err)
	return
}
